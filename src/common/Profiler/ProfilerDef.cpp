/*************************************************************************
 ***                                                                   ***
 ***                  Author: Konstantin Izmailov                      ***
 ***                  kizmailov@gmail.com                              ***
 ***                                                                   ***
 *************************************************************************/

#include "stdafx.h"
#include "ProfilerDef.h"
#include <assert.h>

UINT WM_PGNPROF_STATUS = RegisterWindowMessage(L"PGNPROF_STATUS");

LONGLONG g_qpcFreq;

const WCHAR* TRC_TYPE_STR[] = {
	L"N/A",			// TRC_NONE,
	L"USER",		// TRC_CLIENTSQL,		// SQL from client application
	L"SYSTEM",		// TRC_SYSTEMSQL,		// SQL generated by the Provider
	L"NOTIFY",		// TRC_NOTIFIES,		// notification received from server
	L"ERROR",		// TRC_ERROR,			// Error occurred

	// deprecated SQLType
	L"COLUMNS_SCHEMA",
	L"INDEXES_SCHEMA",
	L"TABLES_SCHEMA",
	L"CATALOGS_SCHEMA",
	L"FOREIGN_KEYS_SCHEMA",
	L"PRIMARY_KEYS_SCHEMA",
	L"PROCEDURE_COLUMNS_SCHEMA",
	L"PROCEDURE_PARAMETERS_SCHEMA",
	L"PROCEDURES_SCHEMA",

	// current SQLType
	L"SYS_SCHEMA",
	L"USER_SCHEMA",

	// comment
	L"COMMENT",
	0
};

const WCHAR* CMD_TYPE_STR[26] = {		// see definition of SQL_QUERY_TYPE in stdafx.h in PQNP project
	L"NONE",
	L"SELECT",
	L"INSERT",
	L"UPDATE",
	L"DELETE",
	L"CREATE DATABASE",
	L"CREATE TABLE",
	L"CREATE VIEW",
	L"CREATE INDEX",
	L"CREATE FUNCTION",
	L"ALTER",

	L"SET",
	L"SHOW",

	L"DROP DATABASE",
	L"DROP TABLE",
	L"DROP VIEW",
	L"DROP INDEX",
	L"DROP FUNCTION",

	L"PROCEDURE",
	L"INTERNALPROC",		// internal stored procedure

	L"START TRANSACTION",
	L"COMMIT",
	L"ROLLBACK",

	L"NOTIFY",
	L"COPY",
	0
};

const WCHAR* CURSOR_TYPE_STR[] = {
	L"Forward only",
	L"Can scroll backwards",
	0
};

const static char dowm[] = { 26, 29, 0, 3, 5, 8, 10, 13, 16, 18, 21, 23 };

// http://www.codeproject.com/Articles/2501/Any-Day-of-the-Week-Using-the-Doomsday-Rule
static int GetDOW(int year, int month, int day)
{
	enum { MARCH=2, SEPTEMBER=8 };
	if (month < MARCH) --year;
	int x = day + dowm[month] + year + year/4;
 
	return ((year > 1752) || (year == 1752) && ((month > SEPTEMBER) || ((month == SEPTEMBER) && day > 13)) ? (x - year/100 + year/400 + 2) : (x)) % 7;
}

static TRC_TIME ParseAbsTime(const char* absTime)
{
    int year, month, day, hour, minute, second, milliseconds;
	int count = sscanf(absTime, "%04d/%02d/%02d %02d:%02d:%02d.%03d", &year, &month, &day, &hour, &minute, &second, &milliseconds);
	if (count == 7)
	{
		int dow = GetDOW(year, month, day);
		SYSTEMTIME sysTime, locTime = { year, month, day, dow, hour, minute, second, milliseconds };
		TzSpecificLocalTimeToSystemTime(NULL, &locTime, &sysTime);

		TRC_TIME rez;
		SystemTimeToFileTime(&sysTime, (LPFILETIME)&rez);

		return rez;
	}

	assert(false);
	return 0;
}

CProfSQLmsg::CProfSQLmsg(BYTE* baseAddr, bool hasData)
	: _baseAddr(baseAddr)
	, PayloadLength(*(DWORD*)baseAddr)
	, TrcType(*(baseAddr + 4))
	, CmdType(*(baseAddr + 5))
	, Cursor(*(baseAddr + 6))
	, License(*(baseAddr + 7))
	, TimeStamp(*(TRC_TIME*)(baseAddr + 8))
	, ParseTime(*(TRC_TIME*)(baseAddr + 16))
	, PrepareTime(*(TRC_TIME*)(baseAddr + 24))
	, ExecTime(*(TRC_TIME*)(baseAddr + 32))
	, GetdataTime(*(TRC_TIME*)(baseAddr + 40))
	, NumRows(*(LONG*)(baseAddr + 48))
	, SessionId(*(SHORT*)(baseAddr + 52))
	, CommandId(*(USHORT*)(baseAddr + 54))
	, _database(0, 0)
	, _user(0, 0)
	, _clientSQL(0, 0)
	, _executedSQL(0, 0)
{
	if (hasData)
	{
		const BYTE* ptr = _baseAddr + 56;

		_database.Length = *(DWORD*)ptr;
		_database.TextPtr = (char*)(ptr + 4);

		ptr += 4 + _database.Length;

		_user.Length = *(DWORD*)ptr;
		_user.TextPtr = (char*)(ptr + 4);

		ptr += 4 + _user.Length;

		_clientSQL.Length = *(DWORD*)ptr;
		_clientSQL.TextPtr = (char*)(ptr + 4);

		ptr += 4 + _clientSQL.Length;

		_executedSQL.Length = *(DWORD*)ptr;
		_executedSQL.TextPtr = (char*)(ptr + 4);
	}
}

CProfSQLmsg::CProfSQLmsg(vector<string>& fields, DWORD payloadLength, DWORD loggerID)
	: _baseAddr(new BYTE[payloadLength])
	, PayloadLength(*(DWORD*)_baseAddr)
	, TrcType(*(BYTE*)(_baseAddr + 4))
	, CmdType(*(BYTE*)(_baseAddr + 5))
	, Cursor(*(BYTE*)(_baseAddr + 6))
	, License(*(BYTE*)(_baseAddr + 7))
	, TimeStamp(*(TRC_TIME*)(_baseAddr + 8))
	, ParseTime(*(TRC_TIME*)(_baseAddr + 16))
	, PrepareTime(*(TRC_TIME*)(_baseAddr + 24))
	, ExecTime(*(TRC_TIME*)(_baseAddr + 32))
	, GetdataTime(*(TRC_TIME*)(_baseAddr + 40))
	, NumRows(*(LONG*)(_baseAddr + 48))
	, SessionId(*(SHORT*)(_baseAddr + 52))
	, CommandId(*(USHORT*)(_baseAddr + 54))
	, _database(0, 0)
	, _user(0, 0)
	, _clientSQL(0, 0)
	, _executedSQL(0, 0)
{
	PayloadLength = loggerID;
	TrcType = TRC_NONE;
	const WCHAR** p = &TRC_TYPE_STR[0];
	for (CA2W wTrcType(fields[1].c_str()); *p != 0; p++)
	{
		if (0 == wcscmp((WCHAR*)wTrcType, *p))
			break;

		TrcType++;
	}
	if (nullptr == *p)
	{
		TrcType = TRC_NONE;
	}

	CmdType = QT_NONE;
	p = &CMD_TYPE_STR[0];
	for (CA2W wCmdType(fields[16].c_str()); *p != 0; p++)
	{
		if (0 == wcscmp((WCHAR*)wCmdType, *p))
			break;

		CmdType++;
	}
	if (nullptr == *p)
	{
		CmdType = QT_NONE;
	}

	Cursor = (fields[14] == "Forward only") ? CURSOR_FORWARD_ONLY : CURSOR_CANSCROLLBACKWARDS;
	License = 0;
	TimeStamp = ParseAbsTime(fields[0].c_str());
	ParseTime = atof(fields[4].c_str()) * g_qpcFreq / 1000.0;
	PrepareTime = atof(fields[5].c_str()) * g_qpcFreq / 1000.0;
	ExecTime = atof(fields[6].c_str()) * g_qpcFreq / 1000.0;
	GetdataTime = atof(fields[7].c_str()) * g_qpcFreq / 1000.0;
	NumRows = atoi(fields[8].c_str());
	SessionId = atoi(fields[12].c_str());
	CommandId = atoi(fields[13].c_str());

	const BYTE* ptr = _baseAddr + 56;

	_database.Length = *(DWORD*)ptr = fields[9].length() + 1;
	_database.TextPtr = (char*)fields[9].c_str();
	strcpy((char*)(ptr + 4), _database.TextPtr);

	ptr += 4 + _database.Length;

	_user.Length = *(DWORD*)ptr = fields[10].length() + 1;
	_user.TextPtr = (char*)fields[10].c_str();
	strcpy((char*)(ptr + 4), _user.TextPtr);

	ptr += 4 + _user.Length;

	_clientSQL.Length = *(DWORD*)ptr = fields[2].length() + 1;
	_clientSQL.TextPtr = (char*)fields[2].c_str();
	strcpy((char*)(ptr + 4), _clientSQL.TextPtr);

	ptr += 4 + _clientSQL.Length;

	_executedSQL.Length = *(DWORD*)ptr = fields[3].length() + 1;
	_executedSQL.TextPtr = (char*)fields[3].c_str();
	strcpy((char*)(ptr + 4), _executedSQL.TextPtr);
}

DWORD CProfSQLmsg::FlushPayload()
{
	return PayloadLength = 56 + 4 + _database.Length + 4 + _user.Length + 4 + _clientSQL.Length + 4 + _executedSQL.Length;
}

DWORD CProfSQLmsg::GetLength()
{
	return ((const BYTE*)_executedSQL.TextPtr + _executedSQL.Length - _baseAddr);
}

CProfERRORmsg::CProfERRORmsg(BYTE* baseAddr, bool hasData)
	: _baseAddr(baseAddr)
	, PayloadLength(*(DWORD*)baseAddr)
	, TrcType(*(baseAddr + 4))
	, Cursor(*(baseAddr + 5))
	, Reserved(*(baseAddr + 6))
	, License(*(baseAddr + 7))
	, TimeStamp(*(TRC_TIME*)(baseAddr + 8))
	, SessionId(*(SHORT*)(baseAddr + 16))
	, CommandId(*(USHORT*)(baseAddr + 18))
	, _database(0, 0)
	, _user(0, 0)
	, _errorText(0, 0)
	, _clientSQL(0, 0)
{
	if (hasData)
	{
		const BYTE* ptr = _baseAddr + 20;

		_database.Length = *(DWORD*)ptr;
		_database.TextPtr = (char*)(ptr + 4);

		ptr += 4 + _database.Length;

		_user.Length = *(DWORD*)ptr;
		_user.TextPtr = (char*)(ptr + 4);

		ptr += 4 + _user.Length;

		_errorText.Length = *(DWORD*)ptr;
		_errorText.TextPtr = (char*)(ptr + 4);

		ptr += 4 + _errorText.Length;

		_clientSQL.Length = *(DWORD*)ptr;
		_clientSQL.TextPtr = (char*)(ptr + 4);
	}
}

CProfERRORmsg::CProfERRORmsg(vector<string>& fields, DWORD payloadLength, DWORD loggerID)
	: _baseAddr(new BYTE[payloadLength])
	, PayloadLength(*(DWORD*)_baseAddr)
	, TrcType(*(BYTE*)(_baseAddr + 4))
	, Cursor(*(BYTE*)(_baseAddr + 5))
	, Reserved(*(BYTE*)(_baseAddr + 6))
	, License(*(BYTE*)(_baseAddr + 7))
	, TimeStamp(*(TRC_TIME*)(_baseAddr + 8))
	, SessionId(*(SHORT*)(_baseAddr + 16))
	, CommandId(*(USHORT*)(_baseAddr + 18))
	, _database(0, 0)
	, _user(0, 0)
	, _errorText(0, 0)
	, _clientSQL(0, 0)
{
	PayloadLength = loggerID;
	TrcType = TRC_ERROR;
	Cursor = (fields[14] == "Forward only") ? CURSOR_FORWARD_ONLY : CURSOR_CANSCROLLBACKWARDS;
	Reserved = 0;
	License = 0;
	TimeStamp = ParseAbsTime(fields[0].c_str());
	SessionId = atoi(fields[12].c_str());
	CommandId = atoi(fields[13].c_str());

	const BYTE* ptr = _baseAddr + 20;

	_database.Length = *(DWORD*)ptr = fields[9].length() + 1;
	_database.TextPtr = (char*)fields[9].c_str();
	strcpy((char*)(ptr + 4), _database.TextPtr);

	ptr += 4 + _database.Length;

	_user.Length = *(DWORD*)ptr = fields[10].length() + 1;
	_user.TextPtr = (char*)fields[10].c_str();
	strcpy((char*)(ptr + 4), _user.TextPtr);

	ptr += 4 + _user.Length;

	_errorText.Length = *(DWORD*)ptr = fields[3].length() + 1;
	_errorText.TextPtr = (char*)fields[3].c_str();
	strcpy((char*)(ptr + 4), _errorText.TextPtr);

	ptr += 4 + _errorText.Length;

	_clientSQL.Length = *(DWORD*)ptr = fields[2].length() + 1;
	_clientSQL.TextPtr = (char*)fields[2].c_str();
	strcpy((char*)(ptr + 4), _clientSQL.TextPtr);
}

DWORD CProfERRORmsg::FlushPayload()
{
	return PayloadLength = 20 + 4 + _database.Length + 4 + _user.Length + 4 + _errorText.Length + 4 + _clientSQL.Length;
}

DWORD CProfERRORmsg::GetLength()
{
	return ((const BYTE*)_clientSQL.TextPtr + _clientSQL.Length - _baseAddr);
}
