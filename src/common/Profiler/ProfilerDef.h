/*************************************************************************
 ***                                                                   ***
 ***                  Author: Konstantin Izmailov                      ***
 ***                  kizmailov@gmail.com                              ***
 ***                                                                   ***
 *************************************************************************/


#pragma once

#define PGNPIPE_PREFIX   L"pgnprof_"

enum { PGNPIPE_PREFIX_LEN = _countof(PGNPIPE_PREFIX) - 1 };

#define PGNPROF_STATUS_STARTUP		0
#define PGNPROF_STATUS_SHUTDOWN		1

extern UINT WM_PGNPROF_STATUS;

typedef LONGLONG TRC_TIME;		// high-precision time used by profiler

// Provider trace types
enum TRC_TYPE : short
{
	TRC_NONE,
	TRC_CLIENTSQL,		// SQL from client application
	TRC_SYSTEMSQL,		// SQL generated by the Provider
	TRC_NOTIFIES,		// notification received from server
	TRC_ERROR,			// Error occurred

	// deprecated SQLType
	TRC_SCHEMA_COLUMNS,
	TRC_SCHEMA_INDEXES,
	TRC_SCHEMA_TABLES,
	TRC_SCHEMA_CATALOGS,
	TRC_SCHEMA_FOREIGN_KEYS,
	TRC_SCHEMA_PRIMARY_KEYS,
	TRC_SCHEMA_PROCEDURE_COLUMNS,
	TRC_SCHEMA_PROCEDURE_PARAMETERS,
	TRC_SCHEMA_PROCEDURES,

	// current SQLType
	TRC_SYS_SCHEMA,
	TRC_USER_SCHEMA,

	// comment
	TRC_COMMENT,

	// startup/shutdown
	TRC_STARTUP,
};

enum CURSOR_TYPE
{
	CURSOR_FORWARD_ONLY,
	CURSOR_CANSCROLLBACKWARDS,
};

enum COMMENT_LEVEL : DWORD
{
	COMMENT_1 = 1,
	COMMENT_2 = 2,
	COMMENT_3 = 3,
};

enum PRMFMT : DWORD
{
	PRMFMT_DEFAULT = 0,
	PRMFMT_NOTRUNC = 1,
	PRMFMT_PGADMIN = 2,
};

struct PROFMSG_TEXT
{
	PROFMSG_TEXT(DWORD len, const char* text) : Length(len), TextPtr(text)
	{}

	DWORD Length;
	const char* TextPtr;
};

class CPGNProfilerView;

class CProfSQLmsg
{
	friend class CPGNProfilerView;

	const BYTE* _baseAddr;

public:
	DWORD& PayloadLength;		// dual purpose field: for File logs it contains logger id, for other logs - the object length
	BYTE& TrcType;				// TRC_TYPE: TRC_CLIENTSQL, TRC_SYSTEMSQL, TRC_NOTIFIES or TRC_ERROR.
	BYTE& CmdType;				// SQL_QUERY_TYPE: QT_SELECT, QT_INSERT, QT_UPDATE, QT_DELETE, ...
	BYTE& Cursor;				// CURSOR_TYPE: FORWARD_ONLY or CANSCROLLBACKWARDS.
	BYTE& License;				// first byte of the license.
	TRC_TIME& TimeStamp;		// absolute FILETIME in the beginning of SQL command or other operation (time measurement).
	TRC_TIME& ParseTime;		// relative parse time (diff after and before).
	TRC_TIME& PrepareTime;		// relative statement preparation time (diff after and before).
	TRC_TIME& ExecTime;			// relative execution time (diff after and before).
	TRC_TIME& GetdataTime;		// relative GetNextRows/GetData time (diff after and before).
	LONG& NumRows;				// number of rows retrieved.
	SHORT& SessionId;
	USHORT& CommandId;

private:
	PROFMSG_TEXT _clientSQL;	// statement text from client app
	PROFMSG_TEXT _executedSQL;	// executed statement
	PROFMSG_TEXT _database;
	PROFMSG_TEXT _user;

public:
	CProfSQLmsg(BYTE* baseAddr, bool hasData);

	CProfSQLmsg(vector<string>& fields, DWORD payloadLength, DWORD loggerID);

	DWORD FlushPayload();

	DWORD GetLength();

	__declspec(property(get = getDatabase, put = putDatabase)) PROFMSG_TEXT Database;

	__declspec(property(get = getUserName, put = putUserName)) PROFMSG_TEXT UserName;

	__declspec(property(get = getClientSQL, put = putClientSQL)) PROFMSG_TEXT ClientSQL;

	__declspec(property(get = getExecutedSQL, put = putExecutedSQL)) PROFMSG_TEXT ExecutedSQL;

	void putDatabase(PROFMSG_TEXT text)
	{
		const BYTE* ptr = _baseAddr + 56;

		*(DWORD*)ptr = _database.Length = text.Length;

		memcpy((char*)(_database.TextPtr = (char*)(ptr + 4)), text.TextPtr, text.Length);
	}

	PROFMSG_TEXT getDatabase()
	{
		return _database;
	}

	void putUserName(PROFMSG_TEXT text)
	{
		const BYTE* ptr = (BYTE*)_database.TextPtr + _database.Length;

		*(DWORD*)ptr = _user.Length = text.Length;

		memcpy((char*)(_user.TextPtr = (char*)(ptr + 4)), text.TextPtr, text.Length);
	}

	PROFMSG_TEXT getUserName()
	{
		return _user;
	}

	void putClientSQL(PROFMSG_TEXT text)
	{
		const BYTE* ptr = (BYTE*)_user.TextPtr + _user.Length;

		*(DWORD*)ptr = _clientSQL.Length = text.Length;

		memcpy((char*)(_clientSQL.TextPtr = (char*)(ptr + 4)), text.TextPtr, text.Length);
	}

	PROFMSG_TEXT getClientSQL()
	{
		return _clientSQL;
	}

	void putExecutedSQL(PROFMSG_TEXT text)
	{
		const BYTE* ptr = (BYTE*)_clientSQL.TextPtr + _clientSQL.Length;

		*(DWORD*)ptr = _executedSQL.Length = text.Length;

		memcpy((char*)(_executedSQL.TextPtr = (char*)(ptr + 4)), text.TextPtr, text.Length);
	}

	PROFMSG_TEXT getExecutedSQL()
	{
		return _executedSQL;
	}

	const BYTE* GetBaseAddr() const { return _baseAddr; }
};


class CProfERRORmsg
{
	friend class CPGNProfilerView;

	const BYTE* _baseAddr;

public:
	DWORD& PayloadLength;		// dual purpose field: for File logs it contains logger id, for other logs - the object length
	BYTE& TrcType;				// TRC_TYPE: TRC_CLIENTSQL, TRC_SYSTEMSQL, TRC_NOTIFIES or TRC_ERROR.
	BYTE& Cursor;				// CURSOR_TYPE: FORWARD_ONLY or CANSCROLLBACKWARDS
	BYTE& Reserved;				// always 0
	BYTE& License;				// first byte of the license.
	TRC_TIME& TimeStamp;		// absolute FILETIME in the beginning of SQL command or other operation (time measurement)
	SHORT& SessionId;
	USHORT& CommandId;

private:
	PROFMSG_TEXT _database;
	PROFMSG_TEXT _user;
	PROFMSG_TEXT _errorText;
	PROFMSG_TEXT _clientSQL;	// optional

public:
	CProfERRORmsg(BYTE* baseAddr, bool hasData);

	CProfERRORmsg(vector<string>& fields, DWORD payloadLength, DWORD loggerID);

	DWORD FlushPayload();

	DWORD GetLength();

	__declspec(property(get = getErrorText, put = putErrorText)) PROFMSG_TEXT ErrorText;

	__declspec(property(get = getClientSQL, put = putClientSQL)) PROFMSG_TEXT ClientSQL;

	__declspec(property(get = getDatabase, put = putDatabase)) PROFMSG_TEXT Database;

	__declspec(property(get = getUserName, put = putUserName)) PROFMSG_TEXT UserName;

	void putDatabase(PROFMSG_TEXT text)
	{
		const BYTE* ptr = _baseAddr + 20;

		*(DWORD*)ptr = _database.Length = text.Length;

		memcpy((char*)(_database.TextPtr = (char*)(ptr + 4)), text.TextPtr, text.Length);
	}

	PROFMSG_TEXT getDatabase()
	{
		return _database;
	}

	void putUserName(PROFMSG_TEXT text)
	{
		const BYTE* ptr = (BYTE*)_database.TextPtr + _database.Length;

		*(DWORD*)ptr = _user.Length = text.Length;

		memcpy((char*)(_user.TextPtr = (char*)(ptr + 4)), text.TextPtr, text.Length);
	}

	PROFMSG_TEXT getUserName()
	{
		return _user;
	}

	void putErrorText(PROFMSG_TEXT text)
	{
		const BYTE* ptr = (BYTE*)_user.TextPtr + _user.Length;

		*(DWORD*)ptr = _errorText.Length = text.Length;

		memcpy((char*)(_errorText.TextPtr = (char*)(ptr + 4)), text.TextPtr, text.Length);
	}

	PROFMSG_TEXT getErrorText()
	{
		return _errorText;
	}

	void putClientSQL(PROFMSG_TEXT text)
	{
		const BYTE* ptr = (BYTE*)_errorText.TextPtr + _errorText.Length;

		*(DWORD*)ptr = _clientSQL.Length = text.Length;

		memcpy((char*)(_clientSQL.TextPtr = (char*)(ptr + 4)), text.TextPtr, text.Length);
	}

	PROFMSG_TEXT getClientSQL()
	{
		return _clientSQL;
	}

	const BYTE* GetBaseAddr() const { return _baseAddr; }
};

#pragma pack(push,4)
class StartupComm
{
	int _id;
	int _payload;
	TCHAR _buffer[4096];

public:
	StartupComm(int id, int payload) : _id(id), _payload(payload)
	{}

	LPCTSTR asBase64();
	void fromBase64(LPCTSTR);

	inline int GetID() const { return _id; }
	inline int GetPayload() const { return _payload; }
};
#pragma pack(pop)
