/*************************************************************************
 ***                                                                   ***
 ***                  Author: Konstantin Izmailov                      ***
 ***                  kizmailov@gmail.com                              ***
 ***                                                                   ***
 *************************************************************************/

#pragma once

#include <string>
#include <vector>
#include "expression.h"

namespace bisparser {

enum BISVAR
{
	BISVAR_NUMERIC,
	BISVAR_TEXT,
	BISVAR_ENUM,
};

#define BISLEX_EOF ((Parser::token::yytokentype)0)
#define BISLEX_UNDEF_IDENT ((Parser::token::yytokentype)1000000)

class CVariable;

union LexemeVal
{
	std::string* sVal;
	double dVal;
	CVariable* vVal;
};

class CVariable
{
public:
	symrec _sym;
	//const char* _name;
	int _index;
	BISVAR _type;

	CVariable(const char* name, int index, BISVAR type);

	int SetEnumVal(int val);
	int SetText(const char* text);
	int SetNumeric(double val);

	int GetIndex() const { return _index; }
};

class CLexeme
{
public:
	Parser::token::yytokentype _type;
	LexemeVal _val;

	CLexeme() : _type(BISLEX_EOF)
	{}

	CLexeme(Parser::token::yytokentype type, LexemeVal val) : _type(type), _val(val)
	{}

	CLexeme(Parser::token::yytokentype type) : _type(type)
	{
		_val.sVal = 0;
	}
};

/** The Driver class brings together all components. It creates an instance of
 * the Parser and Scanner classes and connects them. Then the input stream is
 * fed into the scanner object and the parser gets it's token
 * sequence. Furthermore the driver object is available in the grammar rules as
 * a parameter. Therefore the driver class contains a reference to the
 * structure into which the parsed data is saved. */
class Driver
{
	std::map<std::string, CVariable*> _knownvars;
	std::map<std::string, int> _knownconsts;
	std::vector<CLexeme> _lexemes;
	std::vector<CVariable*> _vars;
	unsigned _lexemeIx;

	int BuildLexemes(const char* text);

	void ClearLexemes();

	int AddKnownVariable(const char* name, int index, BISVAR type);

	int AddKnownConstant(const char* name, int index);

	CVariable* GetKnownVariable(const std::string& name);

	int GetKnownConstant(const std::string& name);

	void UseVariable(CVariable* v);

public:
    Parser _parser;

	/// result of the expr evaluation
	double _bisrez;
	char lastError[256];

	/// construct a new parser driver context
    Driver();
    ~Driver();

    /** Invoke the scanner and parser on an input string.
     * @param input	input string
     * @param sname	stream name for error messages
     * @return		true if successfully parsed
     */
    bool Prepare(const char* input, const char* sname = "noname");

    // To demonstrate pure handling of parse errors, instead of
    // simply dumping them on the standard error output, we will pass
    // them to the driver using the following two member functions.

    /** Error handling with associated line number. This can be modified to
     * output the error e.g. to a dialog box. */
    void error(const class location& l, const std::string& m);

    /** General error handling. This can be modified to output the error
     * e.g. to a dialog box. */
    void error(const std::string& m);

    /** This is the main lexing function. It is generated by flex according to
     * the macro declaration YY_DECL above. The generated bison parser then
     * calls this virtual function to fetch new tokens. */
    virtual Parser::token_type lex(Parser::semantic_type* yylval, Parser::location_type* yylloc);

	vector<CVariable*>& GetVariables()
	{
		return _vars;
	}

	BOOL Evaluate();

	double IsLike(symrec *var, double op, char const *pstr);
	//double IsILike(symrec *var, char const *pstr);		// case-independent like
};

} // namespace bisparser
