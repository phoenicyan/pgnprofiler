/*************************************************************************
 ***                                                                   ***
 ***                  Author: Konstantin Izmailov                      ***
 ***                  kizmailov@gmail.com                              ***
 ***                                                                   ***
 *************************************************************************/

#include "stdafx.h"
#include "resource.h"

#include "PGNProfilerView.h"
#include "LoggerItem.h"
#include "ProfilerServer.h"

extern const WCHAR* TRC_TYPE_STR[];
extern const WCHAR* CMD_TYPE_STR[26];
extern const WCHAR* CURSOR_TYPE_STR[];

// Columns definitions
LVCOLUMN_EX SQLLOG_COLUMNS[] = {
	{ LVCF_FMT|LVCF_WIDTH|LVCF_TEXT, LVCFMT_LEFT, 140, L"AbsTime", -1, 0,0,0, L"Shows either absolute or relative time when the message was generated.", false, L"RelTime" },
	{ LVCF_FMT|LVCF_WIDTH|LVCF_TEXT, LVCFMT_LEFT, 100, L"SQLType", -1, 1,0,0, L"Shows SQL type, e.g. USER for statements sent by user application, SYSTEM for provider generated commands, etc.", true, NULL },
	{ LVCF_FMT|LVCF_WIDTH|LVCF_TEXT, LVCFMT_LEFT, 500, L"ClientSQL", -1, 2,0,0, L"Shows command text either from user application or generated by the provider.", true, NULL },
	{ LVCF_FMT|LVCF_WIDTH|LVCF_TEXT, LVCFMT_RIGHT, 80, L"Parse", -1, 3,0,0, L"Parse time in milliseconds.", true, NULL },
	{ LVCF_FMT|LVCF_WIDTH|LVCF_TEXT, LVCFMT_RIGHT, 80, L"Prepare", -1, 4,0,0, L"Command preparation time in milliseconds.", true, NULL },
	{ LVCF_FMT|LVCF_WIDTH|LVCF_TEXT, LVCFMT_RIGHT, 80, L"Execute", -1, 5,0,0, L"Command execution time in milliseconds.", true, NULL },
	{ LVCF_FMT|LVCF_WIDTH|LVCF_TEXT, LVCFMT_RIGHT, 80, L"GetRows", -1, 6,0,0, L"Rows data read time in milliseconds.", true, NULL },
	{ LVCF_FMT|LVCF_WIDTH|LVCF_TEXT, LVCFMT_RIGHT, 50, L"Rows", -1, 7,0,0, L"Number of rows read or affected during execution of the SQL.", true, NULL },
	{ LVCF_FMT|LVCF_WIDTH|LVCF_TEXT, LVCFMT_RIGHT, 70, L"Database", -1, 8,0,0, L"Database connected.", true, NULL },
	{ LVCF_FMT|LVCF_WIDTH|LVCF_TEXT, LVCFMT_RIGHT, 50, L"UserName", -1, 9,0,0, L"User logged in.", true, NULL },
	{ LVCF_FMT|LVCF_WIDTH|LVCF_TEXT, LVCFMT_RIGHT, 50, L"PID", -1, 10,0,0, L"User application Process ID.", true, NULL },
	{ LVCF_FMT|LVCF_WIDTH|LVCF_TEXT, LVCFMT_RIGHT, 50, L"SessId", -1, 11,0,0, L"OLEDB session ID.", true, NULL },
	{ LVCF_FMT|LVCF_WIDTH|LVCF_TEXT, LVCFMT_RIGHT, 50, L"CmdId", -1, 12,0,0, L"OLEDB Command ID (reserved).", true, NULL },
	{ LVCF_FMT|LVCF_WIDTH|LVCF_TEXT, LVCFMT_LEFT, 100, L"CursorMode", -1, 13,0,0, L"Shows \"Forward Only\" for ADO client cursor or \"Can scroll backwards\" – for ADO server cursor.", true, NULL },
	{ LVCF_FMT|LVCF_WIDTH|LVCF_TEXT, LVCFMT_LEFT, 150, L"Application", -1, 14,0,0, L"User application name and Process ID (origin of the message).", true, NULL },
	{ LVCF_FMT|LVCF_WIDTH|LVCF_TEXT, LVCFMT_LEFT, 100, L"CmdType", -1, 15,0,0, L"Statement type, e.g. SELECT, UPDATE, INSERT, DELETE, CREATE, etc.", true, NULL },
};

int SQLLOG_COLUMNS_CNT = sizeof(SQLLOG_COLUMNS)/sizeof(SQLLOG_COLUMNS[0]);

int FindSQLLOGColumn(const WCHAR* colName)
{
	for (int i=0; i < SQLLOG_COLUMNS_CNT; i++)
	{
		if (0 == wcscmp(SQLLOG_COLUMNS[i].pszText, colName) ||
			(SQLLOG_COLUMNS[i].pszAltText != NULL && 0 == wcscmp(SQLLOG_COLUMNS[i].pszAltText, colName)))
			return i;
	}
	return -1;
}

LRESULT CPGNProfilerView::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
	ATLTRACE2(atlTraceDBProvider, 2, _T("CPGNProfilerView::OnCreate(lParam=%x)\n"), lParam);

	CPGNPOptions* pOptions = *(CPGNPOptions**)lParam;

	LRESULT lResult = DefWindowProc(uMsg, wParam, lParam);

	ModifyStyle(0, LVS_REPORT | LVS_SHOWSELALWAYS | LVS_NOSORTHEADER | LVS_ALIGNTOP | LVS_OWNERDATA);
	SetExtendedListViewStyle(LVS_EX_HEADERDRAGDROP | LVS_EX_FULLROWSELECT /*| LVS_EX_FLATSB | LVS_EX_TRACKSELECT | LVS_EX_GRIDLINES*/);

	CreateColumns();

	m_header.SubclassWindow(GetHeader());
	
	return lResult;
}

void CPGNProfilerView::CreateColumns()
{
	ATLTRACE2(atlTraceDBProvider, 2, _T("CPGNProfilerView::CreateColumns()\n"));

	while (DeleteColumn(0));

	int iCol = 0;
	for (list<wstring>::const_iterator it=m_optionsForEdit.m_visibleColumnsList.begin(); it != m_optionsForEdit.m_visibleColumnsList.end(); it++)
	{
		const WCHAR* p = wcschr(it->c_str(), L':');
		if (!p) continue;
		int i = FindSQLLOGColumn(it->substr(0, p - it->c_str()).c_str());
		if (i < 0) continue;

		m_columnMapping[iCol] = i;

		LVCOLUMN_EX lvc(SQLLOG_COLUMNS[i]);
		lvc.cx = _wtoi(p+1);
		if (lvc.cx < 10 || lvc.cx > 10000)
			lvc.cx = SQLLOG_COLUMNS[i].cx;
		InsertColumn(iCol++, (LVCOLUMN*)&lvc);
	}
}

void CPGNProfilerView::SelectItems(list<DWORD_PTR>& dataList)
{
	int nCount = GetItemCount();
	ATLTRACE2(atlTraceDBProvider, 2, "CPGNProfilerView::SelectItems() nCount=%d\n", nCount);
	int nFirstSelectedItem = -1;

	for (int nItem = 0; nItem < nCount && dataList.size() > 0; nItem++)
	{
		DWORD_PTR data = (DWORD_PTR)GetMessageData(nItem);
		for (auto it = dataList.begin(); it != dataList.end(); it++)
		{
			if (*it == data)
			{
				SetItemState(nItem, LVIS_SELECTED, LVIS_SELECTED);
				if (-1 == nFirstSelectedItem)
					nFirstSelectedItem = nItem;

				dataList.erase(it);	// this is for speed optimization only: the less items in dataList the faster is the loop
				break;
			}
		}
	}

	if (nFirstSelectedItem != -1)
		EnsureVisible(nFirstSelectedItem, FALSE);
}

LRESULT CPGNProfilerView::OnGetdispinfo(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
{
	LV_ITEM* pItem = &((LV_DISPINFO*)pnmh)->item;

	if (pItem->mask & LVIF_TEXT)
	{
		m_pCurLogger->Lock();	// prevent accessing invalidated m_logStart due to remapping in CTraceReader::HandleProcessLoggerOverlappedResult

		const BYTE* baseAddr = m_pCurLogger->GetMessageData(pItem->iItem);
		TRC_TYPE trcType = (TRC_TYPE)baseAddr[4];

		switch (trcType)
		{
		case TRC_CLIENTSQL:
		case TRC_SYSTEMSQL:
		// deprecated SQLType
		case TRC_SCHEMA_TABLES:
		case TRC_SCHEMA_COLUMNS:
		case TRC_SCHEMA_INDEXES:
		case TRC_SCHEMA_CATALOGS:
		case TRC_SCHEMA_FOREIGN_KEYS:
		case TRC_SCHEMA_PRIMARY_KEYS:
		case TRC_SCHEMA_PROCEDURE_COLUMNS:
		case TRC_SCHEMA_PROCEDURE_PARAMETERS:
		case TRC_SCHEMA_PROCEDURES:
		case TRC_NOTIFIES:
		// current SQLType
		case TRC_SYS_SCHEMA:
		case TRC_USER_SCHEMA:
		case TRC_COMMENT:
			{
				CProfSQLmsg profmsg((BYTE*)baseAddr, true);
				const WCHAR* pszText = DisplaySQLmsg(pItem->iSubItem, profmsg, m_pCurLogger->GetLogger2AppnameMap());
				wcsncpy(pItem->pszText, pszText, pItem->cchTextMax-1);
				pItem->pszText[pItem->cchTextMax-1] = 0;
			}
			break;

		case TRC_ERROR:
			{
				CProfERRORmsg profmsg((BYTE*)baseAddr, true);
				const WCHAR* pszText = DisplayERRmsg(pItem->iSubItem, profmsg, m_pCurLogger->GetLogger2AppnameMap());
				wcsncpy(pItem->pszText, pszText, pItem->cchTextMax-1);
				pItem->pszText[pItem->cchTextMax-1] = 0;
			}
			break;

		case TRC_STARTUP:
			{
				CProfSQLmsg profmsg((BYTE*)baseAddr, true);
				const WCHAR* pszText = DisplaySQLmsg(pItem->iSubItem, profmsg, m_pCurLogger->GetLogger2AppnameMap());
				wcsncpy(pItem->pszText, pszText, pItem->cchTextMax - 1);
				pItem->pszText[pItem->cchTextMax - 1] = 0;
			}
			break;
		}

		m_pCurLogger->Unlock();

		//ATLTRACE2(atlTraceDBProvider, 0, L"%s\n", pItem->pszText);
	}

	return 0;
}

LRESULT CPGNProfilerView::InsertOptimizeMenuItem(HMENU hSubMenu)
{
	if (GetSelectedCount() == 1)
	{
		int nItem = GetNextItem(-1, LVNI_SELECTED);
		const BYTE* baseAddr = GetMessageData(nItem);
		TRC_TYPE trcType = (TRC_TYPE)baseAddr[4];
		if (!m_optionsForEdit.m_sOptimizerConnectionString.empty() && (TRC_CLIENTSQL == trcType || TRC_SYS_SCHEMA == trcType || TRC_ERROR == trcType))
		{
			// TODO: should query pgnp_optimizer table (for hash=0 AND enabled='Y') to check if Optimizer enabled
			TCHAR szOptimize[256];
			::LoadString(_Module.GetResourceInstance(), IDS_OPTIMIZE, szOptimize, 255);

			MENUITEMINFO mii = { 
				sizeof(MENUITEMINFO),
				MIIM_ID | MIIM_STRING | MIIM_DATA,
				MFT_STRING,
				MFS_ENABLED,
				IDM_OPTIMIZE,
				NULL, NULL, NULL, NULL,
				szOptimize,
				wcslen(szOptimize),
				0
			};
			::InsertMenuItem(hSubMenu, ID_VIEW_OPTIONS, FALSE, &mii);
		}
	}
	return 0;
}

LRESULT CPGNProfilerView::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
{
	POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
	ATLTRACE("CPGNProfilerView::OnContextMenu(x=%d, y=%d)\n", pt.x, pt.y);
	HMENU hMenu = ::LoadMenu(_Module.GetResourceInstance(),(LPCTSTR)IDR_LISTV_MENU);
	if (hMenu != NULL)
	{
		HMENU hSubMenu = ::GetSubMenu(hMenu,0);
		if(hSubMenu != NULL)
		{
			InsertOptimizeMenuItem(hSubMenu);

			::TrackPopupMenu(hSubMenu, TPM_LEFTBUTTON | TPM_RIGHTBUTTON, pt.x, pt.y, 0, m_hWnd, NULL);

			::PostMessage(m_hWnd, WM_NULL, 0, 0); 
		}

		::DestroyMenu(hMenu);
	}

	return 0;
}

LRESULT CPGNProfilerView::OnEraseBkgnd(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
{
	return 1;
}

LRESULT CPGNProfilerView::OnScroll(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	ATLTRACE2(atlTraceDBProvider, 0, "CPGNProfilerView::OnScroll(vert=%d, %d, %d, %d)\n", uMsg == WM_VSCROLL ? 1 : 0, LOWORD(wParam), HIWORD(wParam), lParam);

	if (uMsg == WM_VSCROLL && LOWORD(wParam) == SB_THUMBTRACK)
	{
		int topIndex = HIWORD(wParam);	// same result as GetTopIndex();

		if (m_prevTopIndex < topIndex)
		{
			int countPP = GetCountPerPage();
			ATLTRACE2(atlTraceDBProvider, 0, "                DOWN  countPerPage=%d\n", countPP);
			EnsureVisible(topIndex + countPP - 1, FALSE);
		}
		else
		{
			ATLTRACE2(atlTraceDBProvider, 0, "                UP\n");
			EnsureVisible(topIndex, FALSE);
		}

		m_prevTopIndex = topIndex;
	}
	else if (uMsg == WM_HSCROLL && LOWORD(wParam) == SB_THUMBTRACK)
	{
		int pos = GetScrollPos(SBS_HORZ);
		SIZE sz = { HIWORD(wParam) - pos, 0 };
		ATLTRACE2(atlTraceDBProvider, 0, "    pos=%d  diff=%d\n", pos, sz.cx);
		Scroll(sz);
	}
	
	bHandled = FALSE;
	return 0;
}

LRESULT CPGNProfilerView::OnSendCmdToMainWnd(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
{
	GetParent().SendMessage(WM_COMMAND, MAKEWPARAM((WORD)wID, BN_CLICKED), (LPARAM)m_hWnd);

	return 0;
}

void CPGNProfilerView::ZoomFont(LONG delta)
{
	ATLTRACE2(atlTraceDBProvider, 2, "CPGNProfilerView::ZoomFont(delta=%d)\n", delta);

	LONG newHeight;
	CHeaderCtrl hdr = GetHeader();
	if ((newHeight = AlterWindowFont(hdr, delta)) != 0)
	{
		// change column size
		float change = 1.0f + (float)delta / (float)(newHeight - delta);
		WCHAR buf[64];
		HDITEM hdi = { HDI_WIDTH, 0, buf, 0, 64 };

		int columnsCount = hdr.GetItemCount();
		for (int ci = 0; ci < columnsCount; ci++)
		{
			hdr.GetItem(ci, &hdi);
			hdi.cxy = (int)(0.5f + change * hdi.cxy);
			hdr.SetItem(ci, &hdi);
		}
	}

	AlterWindowFont(*this, delta);
}

LRESULT CPGNProfilerView::OnMouseWheel(UINT uMsg, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
{
	if ((MK_CONTROL & wParam) != 0)
	{
		ATLTRACE("CPGNProfilerView::OnMouseWheel(delta=%d) -> calling ZoomFont()\n", (int)GET_WHEEL_DELTA_WPARAM(wParam) < 0 ? 2 : -2);
		this->ZoomFont((int)GET_WHEEL_DELTA_WPARAM(wParam) < 0 ? 2 : -2);

		return 0;
	}

	bHandled = FALSE;
	return 1;
}

LRESULT CPGNProfilerView::OnChar(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	if (wParam == '.' || wParam == '>' || wParam == '+' || wParam == '=')
	{
		this->ZoomFont(-2);
		return 1;
	}

	if (wParam == ',' || wParam == '<' || wParam == '-' || wParam == '_')
	{
		this->ZoomFont(2);
		return 1;
	}

	bHandled = FALSE;
	return 0;
}

LRESULT CPGNProfilerView::OnGetDlgCode(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
{
	return DLGC_WANTALLKEYS;
}

static USHORT LVCFMT2TA[] = { TA_LEFT, TA_RIGHT, TA_CENTER };

void CPGNProfilerView::DrawSelectedItem(const NMCUSTOMDRAW& nmcd)
{
	RECT itemRect;
	GetItemRect(nmcd.dwItemSpec, &itemRect, LVIR_BOUNDS);

	itemRect.left += 3;

	HRGN bgRgn = CreateRectRgnIndirect(&itemRect);
	FillRgn(nmcd.hdc, bgRgn, m_palit.m_brBackGndSel);
	DeleteObject(bgRgn);

	COLORREF savedTextColor = ::GetTextColor(nmcd.hdc);

	m_pCurLogger->Lock();	// prevent accessing invalidated m_logStart due to remapping in CTraceReader::HandleProcessLoggerOverlappedResult

	const BYTE* baseAddr = m_pCurLogger->GetMessageData((size_t)nmcd.dwItemSpec);
	TRC_TYPE trcType = (TRC_TYPE)baseAddr[4];
	::SetTextColor(nmcd.hdc, TRC_ERROR == trcType ? Yellow : White);

	CHeaderCtrl hdr = GetHeader();
	int nColumnsCount = hdr.GetItemCount();

	int* nOrderArray = (int*)_alloca(nColumnsCount * sizeof(int));
	GetColumnOrderArray(nColumnsCount, nOrderArray);

	LONG offset = itemRect.left + 3;
	for (int ci = 0; ci < nColumnsCount; ci++)
	{
		WTL::CString strText;
		GetItemText(nmcd.dwItemSpec, nOrderArray[ci], strText);

		HDITEM hdi = { HDI_WIDTH | HDI_FORMAT, 0, nullptr, 0, 64 };
		hdr.GetItem(nOrderArray[ci], &hdi);

		// Note: DrawText/DrawTextEx cannot be used for the purpose of drawing cells here due to the following remark
		// (found here https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-drawtextexa):
		// "The DrawTextEx function supports only fonts whose escapement and orientation are both zero.
		// The text alignment mode for the device context must include the TA_LEFT, TA_TOP, and TA_NOUPDATECP flags."
		// Instead ExtTextOut must be used.
		RECT textRect;
		const int fmtIndex = hdi.fmt & HDF_JUSTIFYMASK;
		SetTextAlign(nmcd.hdc, LVCFMT2TA[fmtIndex]);
		SetRect(&textRect, offset, itemRect.top, offset + hdi.cxy - 12, itemRect.bottom);
		int x = offset;
		if (fmtIndex != 0)
			x += (hdi.cxy - 12) / fmtIndex;	// must specify right border for TA_RIGHT, or center for TA_CENTER
		ExtTextOut(nmcd.hdc, x, itemRect.top + 2, ETO_CLIPPED, &textRect, strText, strText.GetLength(), nullptr);

		offset += hdi.cxy;
	}

	::SetTextColor(nmcd.hdc, savedTextColor);

	m_pCurLogger->Unlock();
}

DWORD CPGNProfilerView::OnItemPrePaint(int /*idCtrl*/, LPNMCUSTOMDRAW lpNMCustomDraw)
{
    NMLVCUSTOMDRAW* pLVCD = reinterpret_cast<NMLVCUSTOMDRAW*>(lpNMCustomDraw);

	//ATLTRACE2(atlTraceDBProvider, 0, L"CPGNProfilerView::OnItemPrePaint(%d)\n", pLVCD->nmcd.dwItemSpec);

	UINT itemState = GetItemState(pLVCD->nmcd.dwItemSpec, LVIS_FOCUSED | LVIS_SELECTED);
	if (itemState != 0)
	{
		DrawSelectedItem(pLVCD->nmcd);
		return CDRF_SKIPDEFAULT;
	}

	m_pCurLogger->Lock();
	const BYTE* baseAddr = m_pCurLogger->GetMessageData((size_t)pLVCD->nmcd.dwItemSpec);
	pLVCD->clrTextBk = GetLineColor((TRC_TYPE)baseAddr[4], (SQL_QUERY_TYPE)baseAddr[5]);
	pLVCD->clrText = m_palit.CrText;
	m_pCurLogger->Unlock();

    // Tell Windows to paint the control itself.
    return CDRF_DODEFAULT;
}

const BYTE* CPGNProfilerView::GetMessageData(size_t i) const
{
	return m_pCurLogger->GetMessageData(i);
}

// Returns TRUE if number of messages changed in Profiler ListView; otherwise - FALSE.
BOOL CPGNProfilerView::ShowMessages(CLoggerItemBase* pLogger)
{
	BOOL msgCountChanged = FALSE;

	if (m_pCurLogger != pLogger)
	{
		m_numMessages = MAXLONG;
		m_pCurLogger = pLogger;
		DeleteAllItems();
		msgCountChanged = TRUE;
		m_prevTopIndex = 0;
	}
	
	if (m_pCurLogger == 0)
		return msgCountChanged;

	size_t numMessages = m_pCurLogger->GetNumMessages();
	if (m_numMessages == numMessages)
	{	// number of messages haven't changed - nothing to do.
		return FALSE;
	}

	ATLTRACE2(atlTraceDBProvider, 0, L"CPGNProfilerView::ShowMessages(numMessages=%d)\n", numMessages);

	if (numMessages == 0)
	{	// messages were cleared
		m_prevTopIndex = 0;
		m_numMessages = 0;
		DeleteAllItems();
		return TRUE;
	}

	if (m_numMessages == MAXLONG)
	{
		m_numMessages = 0;
	}

	int nItemLast = GetItemCount() + numMessages - m_numMessages;
	SetItemCountEx(nItemLast, LVSICF_NOINVALIDATEALL | LVSICF_NOSCROLL);

	m_numMessages = numMessages;

	if (nItemLast > 0 && m_autoScroll)
		EnsureVisible(nItemLast-1, FALSE);

	return TRUE;
}

void CPGNProfilerView::Refresh()
{
	ATLTRACE2(atlTraceDBProvider, 2, "CPGNProfilerView::Refresh()\n");

	m_numMessages = MAXLONG;

	DeleteAllItems();
}


const WCHAR* CPGNProfilerView::DisplaySQLmsg(int nSubItem, CProfSQLmsg& profmsg, map<DWORD, wstring>* pMapLogger2Appname)
{
	m_buffer[0] = 0;

	switch (m_columnMapping[nSubItem])
	{
	case 0:		// Timestamp
		if (m_relativeTime)
			PrintRelTimeStamp(m_buffer, profmsg.TimeStamp, m_pCurLogger->GetInitialTimePtr());
		else
			PrintAbsTimeStamp(m_buffer, profmsg.TimeStamp);
		break;

	case 1:		// SQL Type
		return TRC_TYPE_STR[profmsg.TrcType];

	case 2:		// Client SQL
		return FormatUserReadableSQL(profmsg.ClientSQL.Length > 1 ? profmsg.ClientSQL.TextPtr : profmsg.ExecutedSQL.TextPtr);

	case 3:		// Parse (ms)
		swprintf(m_buffer, _CVTBUFSIZE, L"%1.3lf", (double)profmsg.ParseTime * 1000 / g_qpcFreq);
		break;

	case 4:		// Prepare (ms)
		swprintf(m_buffer, _CVTBUFSIZE, L"%1.3lf", (double)profmsg.PrepareTime * 1000 / g_qpcFreq);
		break;

	case 5:		// Execute (ms)
		swprintf(m_buffer, _CVTBUFSIZE, L"%1.3lf", (double)profmsg.ExecTime * 1000 / g_qpcFreq);
		break;

	case 6:		// GetRows (ms)
		swprintf(m_buffer, _CVTBUFSIZE, L"%1.3lf", (double)profmsg.GetdataTime * 1000 / g_qpcFreq);
		break;

	case 7:		// Rows
		return _itow(profmsg.NumRows, m_buffer, 10);

	case 8:		// Database
		if (profmsg.Database.Length > 1)
		{
			CA2WEX<4000> wsDatabase(profmsg.Database.TextPtr, CP_UTF8);
			wcscpy(m_buffer, wsDatabase);
		}
		break;

	case 9:		// UserName
		if (profmsg.UserName.Length > 1)
		{
			CA2WEX<4000> wsUser(profmsg.UserName.TextPtr, CP_UTF8);
			wcscpy(m_buffer, wsUser);
		}
		break;

	case 10:	// PID
		{
			DWORD pid = 0;
			if (!pMapLogger2Appname)
			{
				CProcessLoggerItem* pLogger = (CProcessLoggerItem*) CLoggerTracker::Instance().GetLogger(*(USHORT*)profmsg._baseAddr);
				pid = pLogger->GetPID();
			}
			return _itow(pid, m_buffer, 10);
		}

	case 11:	// Session
		return _itow(profmsg.SessionId, m_buffer, 10);

	case 12:	// Command
		return _itow(profmsg.CommandId, m_buffer, 10);

	case 13:	// Cursor Mode
		return CURSOR_TYPE_STR[profmsg.Cursor];

	case 14:	// Application Name
		{
			if (pMapLogger2Appname)
			{
				// message from a log file
				map<DWORD, wstring>::const_iterator it = pMapLogger2Appname->find(*(DWORD*)profmsg._baseAddr);
				if (it != pMapLogger2Appname->end())
					return it->second.c_str();
			}
			else
			{
				CLoggerItemBase* pLogger = (CLoggerItemBase*) CLoggerTracker::Instance().GetLogger(*(USHORT*)profmsg._baseAddr);
				return pLogger->GetDisplayName();
			}
			break;
		}
	case 15:	// Command Type
		if (profmsg.CmdType+1 >= sizeof(CMD_TYPE_STR)/sizeof(CMD_TYPE_STR[0]))
			return CMD_TYPE_STR[0];
		return CMD_TYPE_STR[profmsg.CmdType];
	}
	return m_buffer;
}

const WCHAR* CPGNProfilerView::DisplayERRmsg(int nSubItem, CProfERRORmsg& profmsg, map<DWORD, wstring>* pMapLogger2Appname)
{
	m_buffer[0] = 0;

	switch (m_columnMapping[nSubItem])
	{
	case 0:		// Timestamp
		if (m_relativeTime)
			PrintRelTimeStamp(m_buffer, profmsg.TimeStamp, m_pCurLogger->GetInitialTimePtr());
		else
			PrintAbsTimeStamp(m_buffer, profmsg.TimeStamp);
		break;

	case 1:		// SQL Type
		return TRC_TYPE_STR[profmsg.TrcType];

	case 2:		// SQL Statement
		return FormatUserReadableSQL(profmsg.ErrorText.TextPtr);

	case 8:		// Database
		if (profmsg.Database.Length > 1)
		{
			CA2WEX<4000> wsDatabase(profmsg.Database.TextPtr, CP_UTF8);
			wcscpy(m_buffer, wsDatabase);
		}
		break;

	case 9:		// UserName
		if (profmsg.UserName.Length > 1)
		{
			CA2WEX<4000> wsUser(profmsg.UserName.TextPtr, CP_UTF8);
			wcscpy(m_buffer, wsUser);
		}
		break;

	case 10:		// PID
		{
			DWORD pid = 0;
			if (!pMapLogger2Appname)
			{
				CProcessLoggerItem* pLogger = (CProcessLoggerItem*) CLoggerTracker::Instance().GetLogger(*(USHORT*)profmsg._baseAddr);
				pid = pLogger->GetPID();
			}
			return _itow(pid, m_buffer, 10);
		}
	case 11:		// Session
		return _itow(profmsg.SessionId, m_buffer, 10);

	case 12:		// Command
		return _itow(profmsg.CommandId, m_buffer, 10);

	case 13:		// Cursor Mode
		return CURSOR_TYPE_STR[profmsg.Cursor];

	case 14:		// Application Name
		{
			if (pMapLogger2Appname)
			{
				// message from a log file
				map<DWORD, wstring>::const_iterator it = pMapLogger2Appname->find(*(DWORD*)profmsg._baseAddr);
				if (it != pMapLogger2Appname->end())
					return it->second.c_str();
			}
			else
			{
				CLoggerItemBase* pLogger = (CLoggerItemBase*) CLoggerTracker::Instance().GetLogger(*(USHORT*)profmsg._baseAddr);
				return pLogger->GetDisplayName();
			}
			break;
		}
	}
	return m_buffer;
}

void CPGNProfilerView::SetRelativeTime(BOOL relativeTime)
{
	if (m_relativeTime == relativeTime)
		return;

	// update Timestamp column
	m_relativeTime = relativeTime;

	WCHAR buffer[_CVTBUFSIZE];
	int itemCnt = GetItemCount();
	for (int nItem=0; nItem < itemCnt; nItem++)
	{
		m_pCurLogger->Lock();

		DWORD_PTR index = GetItemData(nItem);
		BYTE* baseAddr = (BYTE*)GetMessageData(index);
		TRC_TIME& timeStamp = *(TRC_TIME*)(baseAddr + 8);	// see CProfSQLmsg or CProfERRORmsg ctors

		if (m_relativeTime)
		{
			PrintRelTimeStamp(buffer, timeStamp, m_pCurLogger->GetInitialTimePtr());
		}
		else
		{
			PrintAbsTimeStamp(buffer, timeStamp);
		}

		m_pCurLogger->Unlock();
		
		SetItemText(nItem, 0, buffer);
	}

	// change column name
	WCHAR text[16];
	HDITEM headerItem = {0};
	headerItem.mask = HDI_TEXT | HDI_WIDTH;
	headerItem.pszText = text;
	headerItem.cchTextMax = 16;
	CHeaderCtrl hdr = GetHeader();
	if (hdr.GetItem(m_columnMapping[0], &headerItem))
	{
		headerItem.pszText = m_relativeTime ? SQLLOG_COLUMNS[0].pszAltText : SQLLOG_COLUMNS[0].pszText; //L"RelTime" : L"AbsTime";
		hdr.SetItem(m_columnMapping[0], &headerItem);
	}
}

void CPGNProfilerView::SetAutoScroll(BOOL autoScroll)
{
	m_autoScroll = autoScroll;
	
	ATLTRACE2(atlTraceDBProvider, 2, "CPGNProfilerView::SetAutoScroll(%d)\n", autoScroll);

	if (m_autoScroll)
		EnsureVisible(GetItemCount()-1, FALSE);
}

void PrintAbsTimeStamp(WCHAR* buffer, TRC_TIME timeStamp)
{
	SYSTEMTIME sysTime, locTime;
	FileTimeToSystemTime((FILETIME*)&timeStamp, &sysTime);
	SystemTimeToTzSpecificLocalTime(NULL, &sysTime, &locTime);
	swprintf(buffer, _CVTBUFSIZE, L"%04d/%02d/%02d %02d:%02d:%02d.%03d", locTime.wYear, locTime.wMonth, locTime.wDay, locTime.wHour, locTime.wMinute, locTime.wSecond, locTime.wMilliseconds);
}

void PrintRelTimeStamp(WCHAR* buffer, TRC_TIME timeStamp, LONGLONG* initialTime)
{
	swprintf(buffer, _CVTBUFSIZE, L"%1.7lf", (double)(timeStamp - *initialTime) / g_qpcFreq);
}

const WCHAR* CPGNProfilerView::FormatUserReadableSQL(const char* text)
{
	m_userSQL.clear();

	CA2WEX<4000> wsQuery(text, CP_UTF8);
	for (WCHAR* p = (WCHAR*)wsQuery; *p; p++)
	{
		if (*p == L'\r') continue;
		if (*p == L'\n' || *p == L'\t') m_userSQL += L' ';
		else m_userSQL += *p;
	}
	return m_userSQL.c_str();
}

LRESULT CPGNProfilerView::OnEditCopy(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
{
	int nItem = -1;
	UINT cnt = GetSelectedCount();
	//map<DWORD, wstring> mapLogger2Appname;
	std::wstring txt;
	for (UINT i=0; i < cnt; i++)
	{
		nItem = GetNextItem(nItem, LVNI_SELECTED);

		m_pCurLogger->Lock();

		const BYTE* baseAddr = GetMessageData(nItem);
		//CLoggerItemBase* pLogger = *(CLoggerItemBase**)baseAddr;		!!! don't do this ever !!!
		//DWORD dwLoggerID = *(DWORD*)baseAddr;
		TRC_TYPE trcType = (TRC_TYPE)baseAddr[4];
		if (TRC_ERROR == trcType)
		{
			CProfERRORmsg profmsg((BYTE*)baseAddr, true);

			for (int iSubItem=0; iSubItem < SQLLOG_COLUMNS_CNT; iSubItem++)
			{
				txt += DisplayERRmsg(iSubItem, profmsg, m_pCurLogger->GetLogger2AppnameMap());/*&mapLogger2Appname*/
				txt += L'\t';
			}
			txt += L'\n';
		}
		else
		{
			CProfSQLmsg profmsg((BYTE*)baseAddr, true);
			for (int iSubItem=0; iSubItem < SQLLOG_COLUMNS_CNT; iSubItem++)
			{
				txt += DisplaySQLmsg(iSubItem, profmsg, m_pCurLogger->GetLogger2AppnameMap());/*&mapLogger2Appname*/
				txt += L'\t';
			}
			txt += L'\n';
		}

		m_pCurLogger->Unlock();
	}

	size_t txtlen = txt.size() + 1;

	if (txtlen > 1 && OpenClipboard() != 0)
	{
		HGLOBAL hTmp = GlobalAlloc(GMEM_MOVEABLE, txtlen);
		LPVOID pTmp = GlobalLock(hTmp);
		CW2A temp(txt.c_str());
        memcpy(pTmp, (char*)temp, txtlen);
        EmptyClipboard();
        if (0 == SetClipboardData(CF_TEXT, hTmp))
		{
			// failed to copy text to clipboard
			GlobalFree(hTmp);
		}
		else
		{
			// success!
			GlobalUnlock(hTmp);
		}
		CloseClipboard();
	}
	return 0;
}

LRESULT CPGNProfilerView::OnOptimize(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
{
	if (GetSelectedCount() == 1)
	{
		int nItem = GetNextItem(-1, LVNI_SELECTED);

		m_pCurLogger->Lock();

		const BYTE* baseAddr = GetMessageData(nItem);
		TRC_TYPE trcType = (TRC_TYPE)baseAddr[4];
		if (TRC_CLIENTSQL == trcType || TRC_SYS_SCHEMA == trcType)
		{
			CProfSQLmsg profmsg((BYTE*)baseAddr, true);
			m_optimizerDlg.m_clientSQL.assign(profmsg.ClientSQL.TextPtr, profmsg.ClientSQL.Length - 1);
		}
		else if (TRC_ERROR == trcType)
		{
			CProfERRORmsg errmsg((BYTE*)baseAddr, true);
			if (errmsg.ClientSQL.TextPtr != nullptr && errmsg.ClientSQL.Length > 1)
				m_optimizerDlg.m_clientSQL.assign(errmsg.ClientSQL.TextPtr, errmsg.ClientSQL.Length - 1);
		}

		m_pCurLogger->Unlock();

		m_optimizerDlg.m_pOptionsForEdit = &m_optionsForEdit;
		m_optimizerDlg.Create(GetParent().m_hWnd);
		m_optimizerDlg.ShowWindow(SW_SHOWNORMAL);
	}

	return 0;
}

LRESULT CPGNProfilerView::OnHeaderChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
	::PostMessage(m_hMainWnd, MYMSG_SAVESETTINGS, OT_COLUI, 0);

	return 0;
}

LRESULT CPGNProfilerView::OnHeaderDraged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
	int iw = GetColumnWidth(0);
	PostMessage(LVM_SETCOLUMNWIDTH, 0, MAKELPARAM(iw, 0));

	return 0;
}

void CPGNProfilerView::GetColumnsSizes(wstring& columns)
{
	CHeaderCtrl hdr = GetHeader();
	int nColumnsCount = hdr.GetItemCount();

	int* nOrderArray = (int*)_alloca(nColumnsCount * sizeof(int));
	GetColumnOrderArray(nColumnsCount, nOrderArray);
	
	WCHAR buf[64];
	HDITEM hdi = {HDI_TEXT|HDI_WIDTH, 0, buf, 0, 64 };

	for (int ci=0; ci<nColumnsCount; ci++)
	{
		hdr.GetItem(nOrderArray[ci], &hdi);
		columns += buf;
		columns += L':';
		columns += _itow(hdi.cxy, buf, 10);
		columns += L';';
	}
}

COLORREF CPGNProfilerView::GetLineColor(TRC_TYPE trcType, SQL_QUERY_TYPE cmdType)
{
	COLORREF clr = m_palit.GetDynColor(QCLR_NONE); /*m_crTrcNone;*/
	switch (trcType)
	{
	case TRC_CLIENTSQL:
	case TRC_USER_SCHEMA:
		switch (cmdType)
		{
		case QT_SELECT:	clr = m_palit.GetDynColor(QCLR_SELECT); /*m_crTrcSelect;*/ break;

		case QT_COPY:
		case QT_INSERT: clr = m_palit.GetDynColor(QCLR_INSERT); /*m_crTrcInsert;*/ break;

		case QT_UPDATE: clr = m_palit.GetDynColor(QCLR_UPDATE); /*m_crTrcUpdate;*/ break;
		case QT_DELETE: clr = m_palit.GetDynColor(QCLR_DELETE); /*m_crTrcDelete;*/ break;
		case QT_CREATE_DATABASE:
		case QT_CREATE_TABLE:
		case QT_CREATE_VIEW:
		case QT_CREATE_INDEX:
		case QT_CREATE_FUNCTION:
		case QT_ALTER:
		case QT_DROP_DATABASE:
		case QT_DROP_TABLE:
		case QT_DROP_VIEW:
		case QT_DROP_INDEX:
		case QT_DROP_FUNCTION: clr = m_palit.GetDynColor(QCLR_CREATEDROPALTER); /*m_crTrcAlter;*/ break;	// light green
		case QT_PROCEDURE:
		case QT_INTERNAL_PROC:  clr = m_palit.GetDynColor(QCLR_PROCEDURES); /*m_crTrcInternalProc;*/ break;
		}
		break;

	case TRC_SYSTEMSQL:
		clr = m_palit.GetDynColor(QCLR_SYSTEM); /*m_crTrcSystem;*/
		break;

		// deprecated SQLType
	case TRC_SCHEMA_TABLES:
	case TRC_SCHEMA_COLUMNS:
	case TRC_SCHEMA_INDEXES:
	case TRC_SCHEMA_CATALOGS:
	case TRC_SCHEMA_FOREIGN_KEYS:
	case TRC_SCHEMA_PRIMARY_KEYS:
	case TRC_SCHEMA_PROCEDURE_COLUMNS:
	case TRC_SCHEMA_PROCEDURE_PARAMETERS:
	case TRC_SCHEMA_PROCEDURES:
		// current SQLType
	case TRC_SYS_SCHEMA:
		clr = m_palit.GetDynColor(QCLR_SYSSCHEMA); /*m_crTrcSysSchema;*/
		break;

	case TRC_NOTIFIES:
		clr = m_palit.GetDynColor(QCLR_NOTIFY); /*m_crTrcNotifies;*/	// violet
		break;

	case TRC_ERROR:
		clr = m_palit.GetDynColor(QCLR_ERROR); /*m_crTrcError;*/
		break;

	case TRC_COMMENT:
		clr = m_palit.GetDynColor(QCLR_COMMENT); /*m_crTrcComment;*/	// green 34,177,76
		break;
	}

	return clr;
}
